Practical Deep Learning for Coders, Lesson 8 - Done!


So welcome to the last lesson of Part One of Practical Deep Learning for Coders. It's been a really fun time doing this course, and depending on when you're watching and listening to this you may want to check the forums or the fast.ai website to see whether we have a Part Two planned, which is going to be some time towards the end of 2022. Or if you're if it's already past that then maybe there's even a Part Two already on the website. So Part Two goes a lot deeper than Part One technically, in terms of getting to the point that you should be able to read and implement research papers and deploy models in a very kind of real life situation


So yeah last lesson we started on the Collaborative Filtering notebook and we were looking at Collaborative Filtering and this is where we got to, which is creating your own embedding module, and this is a very cool… this is a very cool place to start the lesson because you're going to learn a lot about what's really going on and it's really important before you dig into this to make sure that you're really comfortable with the 05-liner-model-and-neural-net-from-scratch notebook. So if parts of this are not totally clear, put it aside and redo this notebook because what we're looking at from here are kind of the abstractions that Pytorch and fast.ai add on top of… functionality that we've built ourselves from scratch. So if you remember in the neural network from scratch we built, we initialized a number of coefficients, a couple of different layers, you know, and a bias term and then during as the model trained we updated those coefficients by going through each layer of them and subtracting out the gradients by the learning rate… 


In… you probably noticed that in Pytorch we don't have to go to all that trouble, and I wanted to show you how Pytorch does this. Pytorch… we don't have to keep track of what our coefficients, or parameters, or weights are - Pytorch does that for us. And the way it does that is it looks inside our module and it tries to find anything that looks like a neural network parameter, or a tensor of neural network parameters, and it keeps track of them. And so here is a class we've created called “T” which is a subclass of module and I've created one thing inside it which is something with the attribute “a”, so this is “a” in the “T” module and it just contains three ones. And so the idea is, you know, maybe we're creating a module and this is we're initializing some parameter that we want to train. Now, we can find out what trainable parameters – or just what parameters in genera l – Pytorch knows about in our model by instantiating our model and then asking for the parameters – which you then have to turn that into a list… or in fastcore we have a thing called capital “L” which is like a fancy list which prints out the number of items in the list and shows you those items. Now in this case, when we create our object of type “T” and ask for its parameters we get told there are zero tensors of parameters and a list with nothing in it. Now why is that? We actually said we wanted to create three… a tensor with three ones in it. How would we make those parameters? Well, the answer is that the way you create… the way you tell Pytorch what your parameters are is: you actually just have to put them inside a special object called an “nn.Parameter”. This thing almost doesn't really do anything. In fact last time I checked it really quite literally had almost no code in it... (sometimes these things change, but let's take a look)...


Yeah okay so it's about a dozen lines of code or 20 lines of code, which does almost nothing. It's got a way of being copied, it's got a way of printing itself, it's got a way of saving itself, and it's got a way of being initialized. So Parameter hardly does anything. The key thing is though that when  Pytorch checks to see which parameters should it update when it optimizes, it just looks for anything that's been wrapped in this Parameter class. So, if we do exactly the same thing as before, which is to set an attribute containing a tensor with three ones… in it but this case we wrap it in a Parameter.


We now get told: okay, there's one parameter tensor in this model and it contains a tensor with three ones. And you can see it also actually, by default, assumes that we're going to want –require– a gradient. It's assuming that anything that's a parameter is something that you want to calculate gradients for. Now, most of the time we don't have to do this because Pytorch provides lots of convenient things for us such as what you've seen before “nn.Linear”, which is something that also (contains) creates a tensor. So this would (contain) create a tensor of one by three without a bias term in it. This has not been wrapped in a “nn.Parameter” – but that's okay. Pytorch knows that anything which is basically a layer in a neural net is going to be a parameter, so it automatically considers this a parameter.


So here's exactly the same thing again, I construct my object of type “T”, I'll check for its parameters and I can see there's (three of…) one tensor of parameters and there's our three things. And you'll notice that it's also automatically, randomly, initialized them, which again is generally what we want. So Pytorch does go to some effort to, yeah, try to make things easy for you.


So the, this attribute “a” is a… is a linear layer and it's got a bunch of things in it. One of the things in it is the weights, and that's where you'll actually find the parameters, that is, of type “Parameter”. So a linear layer is something that contains attributes of type “Parameter”. 


Okay so what we want to do is, we want to create something that works just like this did: which is something that creates a matrix which will be trained as we train the model…


Okay so, an embedding is something which, yeah, it's going to create a matrix of this by this, and it will be a parameter and it's something that, yeah, we need to be able to index into, as we did here. And so how, yeah, what is… what is happening behind the scenes, you know, in  Pytorch? It's nice to create these things ourselves from scratch because it means we really understand it.


And so, let's create that exact same module that we did last time but this time we're going to use a function I've created called “create_params()”. You pass in a size, so… such as… in this case – n uses by n factors.  And it's going to call “torch.zeros()” to create a tensor of zeros of the size that you request, and then it's going to do a normal random distribution… so a gaussian distribution… of mean zero standard deviation 0.01 to randomly initialize those, and it'll put the whole thing into an “nn.Parameter”. So that… so this here is going to create an attribute called “user_factors” which will be a parameter containing some tensor of normally distributed random numbers of this size.


Excuse me.


And because it's a parameter that's going to be stored inside… that's going to be available as in parameters in the “Module”...


(Oh why am I sneezing) 


So “user_bias” will be a vector of parameters, “user_factors” will be a matrix of parameters, “movie_factors” will be a matrix “n_movies” by “n_factors”, “movie_bias” will be a vector of “n_movies” and this is the same as before. So now in the forward() we can do exactly what we did before. The thing is, when you put a tensor inside a “Parameter” it has all the exact same features that a tensor has. So, for example, we can index into it.


So this whole thing is identical to what we had before and so that's actually, believe it or not, all that's required to replicate Pytorch's embedding layer from scratch. So let's run those and see if it works. And there it is: it's training. So we'll be able to have a look when this is done, at for example… ((let's have a look)) model.move_bias.


And here it is, right?, it's a “Parameter” containing a bunch of numbers that have been trained.


And as we'd expect it's got 1665 things in, because that's how many movies we have.


So a question from Jona Raphael was: “does ‘torch.zeros’ not produce all zeros?


Yes “torch.zeros” does produce all zeros. But remember, a method that ends in underscore changes in-place the tensor it's being applied to. And so, if you look up “pytorch normal_” you'll see it fills itself with elements sampled from the normal distribution. So this is actually modifying this tensor in place, and so that's why we end up with something which isn't just zeros.


Now this is a bit I find really fun, is, we train this model, but what did it do?


How is it going about predicting who's going to like what movie? What, well, one of the things that's happened is we've created this “movie_bias” parameter which has been optimized and what we could do is we could find which Movie-IDs have the highest numbers here; and the lowest numbers, (so I think this is going to start lowest) and then we can print out… we can look inside our data loaders and grab the names of those movies for each of those five lowest numbers.


And what's happened here? Well, we can see broadly speaking that it has printed out some pretty crappy movies. And, why is that? Well, that's because when it does that matrix product that we saw in the excel spreadsheet last week, it's trying to figure out who's going to like what movie based on previous movies people have enjoyed or not, and then it adds “movie_bias”, which can be positive or negative, that's a different number for each movie. So in order to do a good job of predicting whether you're going to like a movie or not, it has to know which movies are crap, and so the crap movies are going to end up with a very low “movie_bias” parameter, and so we can actually find out which movies, do people… not only which movies do people really not like, but which movies do people like less than one would expect given the kind of movie that it is. So “Lawnmower Man 2”, for example, not only apparently is it a crappy movie but, based on the kind of movie it is (you know, it's kind of like a high-tech pop kind of sci-fi movie…) …people who like those kinds of movies still don't like “Lawnmower Man 2”, so that's what this is meaning. 


So it's kind of nice that we can, like, use a model not just to predict things but to understand things about the data. So if we sort by descending, it'll give us the exact opposite. So here are movies that people enjoy even when they don't normally enjoy that kind of movie. So for example “L.A. Confidential”,  classic kind of film noir detective movie with the aussie Guy Pierce, even if you don't really like film noir detective movies, you might like this one. You know, “Silence of the Lambs”, classic kind of… I guess you'd say like, horror kind of… not horror is it, a suspense movie… even people who don't normally like kind-of serial killer suspense movies tend to like this one.


Now, the other thing we can do is not just look at what's happening in the bias… oh and by the way, we could do the same thing with users and find out, like, which user just loves movies,  even the crappy ones, you know. Dislikes all movies and vice versa. But what about the other thing – we didn't just have bias – we also had movie factors. Which has got the number of movies as one axis and the number of factors as the other and we passed in 50 – what's in that huge matrix?  Well, pretty hard to visualize such a huge matrix and we're not going to talk about the details, but you can do something called PCA, which stands for Principal Component Analysis, and that basically tries to compress those 50 columns down into three columns… and then we can draw a chart of the top two. 


And so this is PCA component number one and this is PCA component number two, and here's a bunch of movies and this is a compressed view of these latent factors that it created. And you can see that they obviously have some kind of meaning, right? So over here towards the right, we've got kind of, you know, very pop mainstream kind of movies. And over here on the left, we've got more of the kind of critically acclaimed gritty kind of movies. And then towards the top we've got very kind of action-oriented and sci-fi movies and then down towards the bottom we've got very dialogue driven movies. So remember, we didn't program in any of these things and we don't have any data at all about what movie is what kind of movie but thanks to the magic of SGD, we just told it to please try and optimize these parameters and the way it was able to predict who would like what movie was it had to figure out what kinds of movies are there or what kind of taste is there for each movie. So I think that's pretty interesting. So this is called “visualizing embeddings” and then this is “visualizing the bias”.


We…


We obviously would rather not do everything both by hand, like this, or even like this, and fast.ai provides an application for collaborative learner [“collab_learner”]. And so we can create one, and this is going to look much the same as what we just had, we're going to say how many latent factors we want and what the “y_range” is: to do the sigmoid and the multiply; and then we can do “fit”, and away it goes…


So let's see how it does.


All right, so, it's done a bit better than our manual one. Let's take a look at the model it created. The model looks very similar to what we created in terms of the parameters. You can see here, these are the two embeddings and these are the two biases, and we can do exactly the same thing… we can look in that model and we can find the – you'll see it's not called movies it's “i” for items, it uses an items… this is the item_bias. So we can look at the item_bias, grab the weights, sort, and we get a very similar result. In this case it's very… even more confident that “L.A. Confidential” is a movie that you should probably try watching even if you don't like those kind of movies. And “Titanic” is right up there as well. Even if you don't really like romancy kind of movies, you might like this one.


Even if you don't like classic detective, you might like this one [Pointing “Rear Window”]


You know, we can have a look at the source code for “collab_learner” and we can see that…


Let's see, “use_nn” is false by default, so where our model is going to be of this type… “EmbeddingDotBias”... so we can take a look at that…  Here it is, and look!, this does look very similar, okay? It's creating an embedding, using the size we requested for each of users-by-factors and items-by-factors and users and items. And then it's wrapping each thing from the embedding in the “forward”, and it's doing the multiply, and it's adding it up, and it's doing the sigmoid. So yeah, it looks exactly the same, isn't that neat?. So you can see that what's actually happening in real models is not, yeah, it's not… it's not that weird or magic.


So Kurian is asking: “is PCA useful in any other areas?” And the answer is: absolutely! And what I suggest you do –if you're interested– is check out our (~contra) “Computational Linear Algebra” course.


It's five years old now but it... I mean… this is stuff which hasn't changed for decades really and this will teach you all about things like PCA and stuff like that. It's not nearly as directly practical as “Practical Deep Learning for Coders” but it's definitely, like, very interesting and it's the kind of thing which, if you want to go deeper, you know, it can become pretty useful later along your path. 


Okay, so here's something else interesting we can do: let's grab the “movie_factors”. So that's in our model, it's the item weights [“i_weights”] and it's the “weight” attribute that Pytorch creates. Okay, and now we can convert the movie “Silence of the Lambs” into its “class_id” and we can do that with object-to-id “o2i”, for the titles. And so that's the movie index of “Silence of the Lambs”. And what we can do now is we can look through all of the movies in our latent factors and calculate how far apart (~the) each vector is, each embedding vector is from this one. And this “CosineSimilarity” is very similar to basically the “Euclidean Distance”, you know, the kind of the Root Sum Squared of the… of the differences, but it normalizes it. So it's basically the angle between the vectors. So this is going to calculate how similar each movie is to the “Silence of the Lambs” on, based on these latent factors. And so then we can find which ID is the closest. Yeah, so based on this embedding distance, the closest is “Dial M for Murder”… which makes a lot of sense.


I'm not going to discuss it today but in the book there's also some discussion about what's called the Bootstrapping Problem, which is the question of, like, if you've got a new company, or a new product, how would you get started with making recommendations given that you don't have any previous history with which to make recommendations and that's a very interesting problem that you can read about in the book.


Now… that's one way to do Collaborative Filtering, which is where we create that… do that matrix completion exercise using all those dot products. There's a different way however, which is we can use Deep Learning. And to do it with Deep Learning, what we could do is, we can… we could basically create our user and item embeddings as per usual and then we could create a sequential model.  So a sequential model is just layers of a Deep Learning Neural Network in order.


And, what we could do is we could just concatenate… so in “forward” we could just concatenate the user and item embeddings together, and then do a reLU. So this is… this is basically a single Hidden Layer Neural Network, and then a linear layer at the end to create a single output. So this is the very, you know, world's most simple neural net exactly the same as the style that we created back here in our “...neural net from scratch.” This is exactly the same, but we're using  Pytorch's functionality to do it more easily.


So, in the “forward” here we're gonna, in the same… exactly the same way as we have before, we'll look up the user embeddings and we'll look up the item embeddings and then this is new, this is where we concatenate those two things together and put it through our Neural Network and then finally do our sigmoid.


Now, one thing different this time is that we're going to ask fast.ai to figure out how big our embeddings should be, and so fast.ai has something called get embedding sizes [“get_emb_sz”]. And it just uses a rule of thumb that says that: for 944 users we recommend 74 factor embeddings and for 1,665 movies (or is it the other way around, I can't remember) we recommend 102 factors for your embeddings – so that's what those sizes are. So now we can create that model and we can pop it into a learner and fit in the usual way.


And so, rather than doing all that from scratch, what you can do is you can do exactly the same thing that we've done before: which is to call collaborative learner [“collab_learner”], but you can pass in the parameter use neural network [“use_nn”] equals True, and you can then say how big do you want each layer. So this is going to create a two hidden layer Deep Learning Neural Net: the first will have (~1500) [100] and the second will have 50. And then you can say “fit” and away it goes. 


Okay so here is our… oh we got 0.87… so these are doing less well than our dot product version which is not too surprising because kind of the dot product version is really trying to take advantage of our understanding of the problem domain.  In practice, nowadays, a lot of companies kind of combine…they kind of create a combined model that have a has a Dot Product component and also has a Neural Net component. The Neural Net component is particularly helpful if you've got metadata, for example information about your users, like: when did they sign up; how old are they; what sex are they; you know, where are they from. And then those are all things that you could concatenate in, with your embeddings, and ditto with metadata about the movie: how old is it; what genre is it; and so forth.


All right, so, we've got a question from Jona which I think is interesting. And the question is: “is there an issue where the bias components are overwhelmingly determined by the non-experts in a genre?”


In general, actually there's a more general issue which is, in Collaborative Filtering Recommendation Systems, very often a small number of users or a small number of movies overwhelm everybody else and the classic one is Anime. A relatively small number of people watch Anime and those group of people watch a lot of Anime. So in movie recommendations, like, there's a classic problem which is every time people try to make a list of well-loved movies all the top ones seem to be anime. And so you can imagine what's happening in the matrix completion exercise is that there are... yeah some… some users that just, you know, really watch this one genre of movie and they watch an awful lot of them. So in general you actually do have to be pretty careful about the, you know, these subtlety kind-of issues. And yeah I won't go into details about how to deal with them but they generally involve taking various kinds of ratios, or normalizing things or so forth.


All right, so, that's Collaborative Filtering, and, I wanted to show you something interesting then about embeddings, which is that embeddings are not just for Collaborative Filtering. And in fact, if you've heard about embeddings before you've probably heard about them in the context of Natural Language Processing. So you might have been wondering, back when we did the Hugging Face transformers stuff, how did we go about, you know, using text as inputs to models. And we talked about how you can turn words into integers… we make a list… 


So here's… here's the movie (sorry...) here's the the poem “I am Sam”: 
I am Daniel / I am Sam / Sam I am / That Sam-I-am, et cetera, et cetera. 


We can find a list of all the unique words in that poem and make this list here. And then we can give each of those words a unique id, just arbitrarily, well actually in this case it's alphabetical order, but it doesn't have to be. And so we kind of talked about that and that's what we do with categories in general, but how do we turn those into like, you know, lists of random numbers. And you might not be surprised to hear, what we do is: we create an embedding matrix. So here's an embedding matrix containing four latent factors for each word in the vocab. So here's each word in the vocab and here's the embedding matrix. So if we then want to present this poem to a Neural Net… then what we do is we list out our poem – I do not like that,  Sam-I-am / Do you like Green eggs and ham, etc. Then for each word we look it up… so in Excel, for example, we use “MATCH”, so that will find this word over here and find it is word id 8 and then we will find the 8th word and the first embedding. And so that gives us…


(that's not right, eight?)...


Oh no, that is right, sorry. Here it is, it's just weird column widths. So it's going to be 0.22, then 0.1, 0.01 and here it is 0.22, 0.1, 0.01 etc. So this is the embedding matrix we end up with for this poem. And so if you wanted to train, or use a trained neural network on this poem, you basically turn it into this matrix of numbers. And so, this is what an embedding matrix looks like in an NLP model and it works exactly the same way, as you can see. And then you can do exactly the same things in terms of interpretation of an NLP model by looking at both the bias factors and the latent factors in a word embedding matrix.


So hopefully you're getting the idea here that… our, you know, our different models, you know, the inputs to them… they're based on a relatively small number of, kind of, basic principles. And these principles are generally things like: look up something in array. And then we know, inside the model, we're basically multiplying things together, adding them up and replacing the negatives with zeros. So hopefully you're getting the idea that what's going on inside a Neural Network is generally not that complicated, but it happens very quickly and at scale.


Now, it's not just Collaborative Filtering and NLP but also Tabular Analysis. So, in Chapter 9 of the book we've talked about how Random Forests can be used for this, which was for… this is for the thing where we're predicting the auction sale price of industrial heavy equipment like bulldozers. Instead of using a Random Forest, we can use a Neural Net. 


Now, in this data set, there are some continuous columns and there are some categorical columns. Now, I'm not going to go into the details too much, but in short, we can separate out the continuous columns and categorical (~problem) columns using “cont_cat_split” and that will automatically find which is which based on their data types.


And so in this case it looks like… okay so continuous columns, the elapsed sale date, so I think it's the number of seconds, or years, or something since the start of the data set, is a continuous variable.


And then here are the “cat”, the categorical variables. So for example there are six different product sizes and two coupler systems, 5059 model descriptions, 6 enclosures, 17 tire sizes and so forth.


So, we can use fast.ai, basically, to say: okay, we'll take that data frame and pass in the categorical and continuous variables, and create some random splits, and what's the dependent variable, and we can create data loaders from that. And from that we can create a “tabular_learner”; and basically what that's going to do is… it's going to create a pretty regular, multi-layer neural network, not that different to this one, that we created by hand. 


And each of the categorical variables, it's going to create an embedding for it. And so I can actually show you this, right? So we're going to use “tabular_learner” to create the “learner” and so “tabular_learner” is one, two, three, four, five, six, seven, eight, nine lines of code. And basically the main thing it does is create a “TabularModel”. And so then “TabularModel”, you're not going to understand all of it, but you might be surprised at how much. So a “TabularModel” is a module, we're going to be passing in how big is each embedding going to be, and “tabular_learner”... what's that passing in? It's gonna call get embedding sizes [“get_emb_sz”] just like we did manually before –automatically.  So that's how it gets its embedding sizes and then it's going to create an “Embedding” for each of those embedding sizes [“emb_szs”], from number of inputs, to number of factors.


“Dropout” we're going to come back to later. “BatchNorm” we won’t do until part two.


So then it's going to create a layer, for each of the layers we want, which is going to contain a linear layer, followed by batch norm, followed by drop out [“LinBnDrop”]. It's going to add the “SigmoidRange” we've talked about at the very end. And so the “forward()”, this is the entire thing! If there's some embeddings, it'll go through and get each of the embeddings using the same indexing approach we've used before. It'll concatenate them all together, and then it'll run it through the layers of the neural net, which are these.


So yeah, we don't know all of those details yet, but we know quite a few of them. So that's encouraging, hopefully. And once we've got that, we can do the standard “lr_find” and “fit”.


Now, this exact dataset was used in a Kaggle competition… this dataset was in a Kaggle competition… and the third place getter published a paper about their technique and it's basically the exact, almost the exact one, I'm showing you here. So it wasn't this, sorry, it wasn't this data set, it was a dataset, it was a different one, it was about predicting the amount of sales in different stores…


But they, they used this basic kind of technique. And one of the interesting things is that they used a lot less manual feature engineering than the other high placed entries. Like they had a much simpler approach, and one of the interesting things they published a paper about their approach.  So they published a paper about their approach. So this is the team, from this company, and they basically describe here exactly what I just showed you – these different embedding layers being concatenated together and then going through a couple of layers of a neural network, and it's showing here… it points out in the paper exactly what we learned in the last lesson, which is, embedding layers are exactly equivalent to linear layers on top of a one-hot encoded input.  And, yeah, they found that their technique worked really well. One of the interesting things they also showed is that you can take, you can create your Neural Net, get your trained embeddings, and then you can put those embeddings into a Random Forest or Gradient Booster Tree and your Mean Average Percent Error will dramatically improve. So you can actually combine Random Forests and embeddings or Gradient Boosted Trees and embeddings, which is really interesting. 


Now, what I really wanted to show you though is, what they then did… so, as I said this was a thing about the predicted amount that different products would sell for at different shops around Germany. And what they did was they had a… so, one of their embedding matrices was embeddings by region, and then they did… I think this is a PCA (Principal Component Analysis) of the embeddings for their German regions and when they create a chart of them, you can see that the locations that close together in the embedding matrix are the same locations that are close together in Germany. So you can see here's the blue ones and here's the blue ones. And again, it's important to recognize that the data that they used had no information about the location of these places, the fact that they are close together geographically is something that was figured out as being something that actually helped it to predict sales.


And so, in fact, they then did a plot showing: each of these dots is a shop (a store) and it's showing: for each pair of stores, how far away is it in real life (in metric space) and then how far away is it in embedding space. And there's this very strong correlation, right? So, it's, you know, it's kind of reconstructed somehow (~this kind of) the kind of the geography of Germany, by figuring out how people shop. And similar for days of the week, so there was no information, really, about days of the week but when they put it on the embedding matrix the days of the week: Monday, Tuesday, Wednesday – close to each other. Thursday, Friday – close to each other. As you can see, Saturday and Sunday – close to each other. And ditto for months of the year: January, February, March, April, May, June. So yeah, really interesting, cool stuff, I think, what's actually going on inside a Neural Network.


All right, let's take a 10 minute break and I will see you back here at 7:10. 




All right folks, this is something I think is really fun, which is: we're going to… we've looked at what goes into the start of a model “the input”. We've learned about how they can be categories, or embeddings, and embeddings are basically kind of one-hot-encoded (~category) categories with a little compute trick, or they can just be continuous numbers. We've learned about what comes (~the other) at the other side, which is a bunch of activations, so just a bunch of tensors of numbers which we can use things like softmax to constrain them to add up to one and so forth. And we've looked at what can go in the middle, which is the… matrix multiplies, sandwiched together with, you know, as rectified linear units. And I mentioned that there are other things that can go in the middle as well but we haven't really talked about what those other things are.


So I thought we might look at one of the most important and interesting version of things that can go in the middle, but what you'll see is it turns out it's actually just another kind of matrix multiplication. Which might not be obvious at first but I'll explain. We're going to look at something called a convolution – and convolutions are at the heart of a convolutional neural network. So, the first thing to realize is a convolutional neural network is very, very, very similar to the neural networks we've seen so far – it's got inputs, it's got things that are a lot like, or actually are a form of, matrix multiplication sandwiched with activation functions which can be rectified linear. But there's a particular thing which makes them very useful for computer vision. And I'm going to show you using this excel spreadsheet that's in our repo called “conv-example”. And we're going to look at it using an image from MNIST. So MNIST is kind of the world's most famous computer vision dataset (I think) because it was like the first one, really, which really showed image recognition being… being cracked. It's pretty small by today's standards, it's a dataset of handwritten digits, each one is 28 by 28 pixels. But it, yeah, you know, back in the mid 90s Yann LeCun showed, you know, really practically useful performance on this dataset and as a result ended up with convnets being used in the american banking system for reading checks. 


So here's an example of one of those digits, this is a seven that somebody drew – it's one of those ones with a stroke through it – and this is what it looks like. This is… this is the image. And so I got it from MN… this is just one of the images from MNIST which I put into Excel. 


And what you see in the… in the next column is a version of the image where the horizontal lines are being recognized and another one where the vertical lines are being recognized. And if you think back to that Zeiler and Fergus paper that talked about what the layers of a neural net does, this is absolutely an example of something that we know that the first layer of a neural network tends to learn how to do. Now, how did I do this? I did this using something called a convolution and so, what we're going to do now is, we're going to zoom in to this excel notebook. We're going to keep zooming in. We're going to keep zooming in. So take a look.. keep an eye on this… on this image, and you'll see that once we zoom in enough, it's actually just made of numbers which, as we discussed in the very first… in the very first lesson, we saw how images are made of numbers.


So here they are, right? Here are the numbers, between zero and one. And what I just did is, I just used a little trick, I used Microsoft Excel's conditional formatting to basically make things: the higher numbers more red. So that's how I turn this Excel sheet and I've just rounded it off to the nearest decimal, but it's actually, they're actually bigger than that. So yeah, so here is the image as numbers. 


And so let me show you how we went about creating this top edge detector. What we did was we created this formula… (don't worry about the MAX…) let's focus on this... what it's doing is… have a look at the colored in areas… it's taking each of these cells and multiplying them by each of these cells, and then adding them up. And then we do the rectified linear part which is, if that ends up less than zero, then make it zero. So this is a, this is like a rectified linear unit but it's not doing the normal matrix product, it's doing the equivalent of a dot product but just on these nine cells, and with just these nine weights. 


So you might not be surprised to hear that if I move now one to the right, then now it's using the next nine cells, all right? So if I move, like, to the right quite a bit and down quite a bit to here, it's using these nine cells. So it's still doing a dot product, right? …which as we know is a form of matrix multiplication, but it's doing it in this way where it's kind of taking advantage of the… of the geometry of this situation that the things that are close to each other are being multiplied by this consistent group of the same nine weights each time, because there's actually 28 by 28 numbers here, right? Which I think is 768... 28 times 28. That’s close enough, 784, but (~we don't want, we're not) we don't have 784 parameters, we only have nine parameters. And so, this is called a convolution. So a convolution is where you basically slide this, kind of, little 3 by 3 matrix across a bigger matrix and at each location you do a dot product of the corresponding elements of that 3 by 3 with the corresponding elements of this 3 by 3 matrix of coefficients. Now, why does that create something that finds, as you see, top edges. Well, it's because of the particular way I constructed this 3 by 3 matrix. What I said was that all of the rows, just above, (so these ones) are going to get a one, and all of the ones just below are going to get a minus one, and all of the ones in the middle are going to get a zero. So let's think about what happens somewhere like here, right? That is (let's try to find the right one… here it is…) …so here we're going to get (1 x 1) + (1 x 1) + (1 x 1) - (1 x 1) - (1 x 1) - (1 x 1). We're going to get 0.


But what about up here. Here we're going to get (1 x 1) + (1 x 1) + (1 + 1). These do nothing because they're ( x 0),  minus (1 x 0). So we're going to get 3. So we're only going to get 3 (the highest possible number) in the situation where these are all as black as possible, or in this case as red as possible, and these are all white. And so that's only going to happen at a horizontal edge.


So the one underneath it does exactly the same thing, exactly the same formulas (oopsie daisy.)
The one underneath are exactly the same formulas, a 3 by 3 sliding thing here, but this time we've got a different mat… different little mini matrix of coefficients which is all ones going down and all minus ones going down. And so, for exactly the same reason, this will only be three in situations where they're all one here and they're all zero here.


So, you can think of a convolution as being a sliding window of little mini dot products of these little 3 by 3 matrices. And they don't have to be 3 by 3, right? You could have, we could just have easily done 5 by 5 and then we'd have a 5 by 5 matrix of coefficients –or whatever, whatever size you like. So the size of this is called its kernel size. This is a 3 by 3 kernel for this convolution.


So then, because this is deep learning, we just repeat the… we just repeat these steps again, and again and again. So this is… this layer I'm calling “Conv1” – it's the first convolutional layer. So “Conv2” is going to be a little bit different because on “Conv1” we only had a single channel input: it's just black and white or, you know, yeah, black and white, grayscale, one channel.


But now we've got two channels. We've got the (let's make it a little smaller so we can see better). We've got the horizontal edges channel and the vertical edges channel. And would have a similar thing in the first layer of its color, we'd have a red channel, a green channel and blue channel. So now our filter (this is called the filter, this little mini matrix is called the filter), our filter… our filter now contains a 3 x 3 x depth 2 (or if you want to think of another way) two 3 x 3 kernels, or one 3 x 3 x 2 kernel. And we basically do exactly the same thing, which is we're going to multiply each of these, by each of these, and sum them up. But then we do it for the second bit as well, we multiply each of these, by each of these, and sum them up. And so that gives us… and I think I just picked some random numbers here, right?. So this is going to now be something which can combine… oh sorry, the set… the second one, the second set… so it's, sorry… each of the red ones, by each of the blue ones (that's here) plus each of the green ones, times each of the mauve ones (that's here). So this first filter is being applied to the horizontal edge detector and the second filter is being applied to the vertical edge detector and as a result, we can end up with something that combines features of the two things.


And so then we can have a second channel over here, which is just a different bunch of convolutions for each of the two channels, this one times this one, again, you can see the colors.


So, what we could do is if, you know, once we kind of get to the end we'll end up (as I'll show you how in a moment) we'll end up with a single set of ten activations, one per num-digit we're recognizing – zero to nine. Or, in this case I think we could just create one, you know, maybe we're just trying to recognize nothing but the number seven, or not the number seven. So we could just have one activation. And then we would back propagate through this using SGD in the usual way. And that is going to end up optimizing these numbers. So in this case I manually put in the numbers I knew would create edge detectors. In real life you start with random numbers and then you use SGD to optimize these parameters.


Okay, so there's a few things we can do next and I'm gonna, I'm gonna show you the way that was more common a few years ago and then I'll explain some changes that have been made more recently. What happened a few years ago was we would then take these activations, which as you can see these activations now are kind of in a grid pattern, and we would do something called Max Pooling. And Max Pooling is kind of like a convolution (it's a sliding window) but this time as the sliding window goes across (so here, we're up to here) we don't do a dot product over a filter, but instead we just take a maximum (see here), just this is the maximum of these four numbers, and if we go across a little bit this is the maximum of these four numbers, go across a bit, go across a bit, and so forth (oh that goes off the edge). And you can see what happens when this is called a 2 by 2 Max Pooling.


So, you can see what happens, with the 2 by 2 max pooling we end up losing half of our activations on each dimension, so we're going to end up with only one quarter of the number of activations we used to have. And that's actually a good thing because if we keep on doing convolution, max pool, convolution, max pool, we're going to get fewer and fewer and fewer activations, until eventually, we'll just have one left, which is what we want. That's effectively what we used to do, but, the other thing I mentioned is we didn't normally keep going until there's only one left. What we used to then do is we'd basically say: okay, at some point, we're going to take all of the activations that are left and we're going to basically just do a dot product of those with a bunch of coefficients, not as a convolution but just as a normal linear layer (and this is called the Dense Layer) and then we would add them all up. So we basically end up with a final big dot product of all of the max pooled activations by all of the weights, and would do that for each channel and so that would give us our final activation. And as I say here, MNIST would actually have 10 activations so you'd have a separate set of weights for each of the digits you're predicting and then softmax after that.


Okay, nowadays we do things very slightly differently, nowadays we normally don't have Max Pool layers but instead, what we normally do is, when we do our sliding window (like this one here) we don't normally… let's go back to see… so when I go one to the right… so currently we're starting in cell column “G”, if I go one to the right the next one is column “H”, and if I go one to the right the next one starts in column “I”. So you can see it's sliding the window over every 3 by 3. Nowadays what we tend to do instead is we generally skip one, so we would normally only look at every second. So we would after doing column “I”, we would skip columns “J” and would go straight to column “K” and that's called a Stride 2 Convolution. We do that both across the rows and down the columns. And what that means is every time we do a convolution, we reduce our effective kind of feature size (grid size) by two on each axis, so it reduces it by four in total. So that's basically, instead of doing Max Pooling. And then the other thing that we do differently is nowadays we don't normally have a single dense layer at the end (a single matrix multiply at the end) but instead what we do… we generally keep doing stride 2 convolutions so each one is going to reduce the grid size by 2 x 2, we keep going down until we've got about a 7 by 7 grid and then we do a single pooling at the end. And we don't normally do max pool nowadays – instead we do an average pool. So we average the activations of each one of the 7 by 7 features.


This is actually quite important to know because if you think about what that means, it means that something like an ImageNet style image detector is going to end up with a 7 by 7 grid – let's say it's trying to say, is this a bear? – and in each of the parts of the 7 by 7 grid it's basically saying: is there a bear in this part of the photo?, is there a bear in this part of the photo? is there a bear in this part of the photo? And then it takes the average of those 49 (7 x 7) predictions to decide whether there's a bear in the photo. That works very well if it's basically a photo of a bear, right, because most, you know, if it's… if the bear is big and takes up most of the frame then most of those 7 by 7 bits are bits of a bear. On the other hand, if it's a teeny tiny bear in the corner, then potentially only one of those 49 squares has a bear in it, and even worse if it's like a picture of lots and lots of different things, only one of which is a bear, it could end up not being a great bear detector.  And so this is where, like, the details of how we construct our model turn out to be important. And so, if you're trying to find, like, just one part of a photo that has a small bear in it, you might decide to use (~average pool… sorry) maximum pooling instead of average pooling because max-pooling will just say: I think this is a picture of a bear if any one of those 49 bits of my grid has something that looks like a bear in it.


So these are, you know, these are potentially important details which often get hand waved over.


Although, you know, again like, the key thing here is that… this is happening right at the very end, right, that max pool or that average pool, and actually fast.ai handles this for you – we do a special thing which we, kind of, independently invented (I think we did it first) which is, we do both max pool and average pool and we concatenate them together. We call that Concat Pooling and that has since been reinvented in at least one paper. And so that means that you don't have to think too much about it because we're going to try both for you, basically.


So I mentioned that this is actually really just matrix multiplication and to show you that, I'm going to show you some images created by a guy called Matt Kleinsmith who did this… actually, I think this was in our very first ever course (might have been the Part 2, first Part 2 course) …and he basically pointed out that in a certain way of thinking about it, it turns out that convolution is the same thing as a matrix multiplier. So I want to show you how he shows this. He basically says, okay, let's take this 3 by 3 image and a 2 by 2 kernel containing the coefficients alpha, beta, gamma, delta.


And so, in this… as we slide the window over, each of the colors… each of the colors are multiplied together: red by red, plus green by green, plus (what is that?) orange by orange, plus blue blue, gives you this. And so to put it another way algebraically P = alpha x A + beta x B… et cetera.


And so then, as we slide to this part, we're multiplying again: red by red, green by green and so forth, so we can say Q = alpha x B + beta x C etc. And so this is how we calculate a convolution using the approach we just described, as a sliding window.


But here's another way of thinking about it. We could say: okay, we've got all these different things: a, b, c, d, e, f, g, h, j.  Let's put them all into a single vector and then let's create a single matrix that has alpha, alpha, alpha, alpha; beta, beta, beta, beta, et cetera. And then if we do this matrix multiplied by this vector we get this.


With these grey zeros in the appropriate places, which gives us this, which is the same as this. And so this shows that a convolution is actually a special kind of matrix multiplication: it's a matrix multiplication where there are some zeros that are fixed and some numbers that are forced to be the same. Now, in practice, it's going to be faster to do it this way, but it's a useful kind of thing to think about, I think that just to realize like: oh! it's just another of these special types of matrix multiplications.


Okay, I think… well, let's look at one more thing. Because there was one other thing that we saw, and I mentioned we would look at, in the tabular model, which is called Dropout, and I actually have this in my excel spreadsheet. If you go to the “conv-example (dropout)” page … you'll see we've actually got a little bit more stuff here. We've got the same input as before and the same first convolution as before and the same second convolution as before. And then we've got a bunch of random numbers. They're showing as between 0 and 1, but they're actually… (that's just because they're rounding off…) they're actually random numbers between, you know, that are floats between 0 and 1.


Over here we're then saying… if… let's have a look… so way up here (I'll zoom in a bit) I've got a dropout factor – let's change this, say to 0.5, there we go. 


So over here this is something that says: if the random number in the equivalent place is greater than 0.5, then 1, otherwise 0. And so here's a whole bunch of 1 and 0. Now this thing here is called a dropout mask.


Now what happens is: we multiply (over here), we multiply the dropout mask and we multiply it by our filtered image. And what that means is we end up with exactly the same image we started with… (here's the image we started with…) but it's corrupted. Random bits of it have been deleted, and based on the amount of dropout we use – so if we change it to, say, 0.2 – not very much of it's deleted at all, so it's still very easy to recognize. Or else if we use lots of dropouts, say 0.8, it's almost impossible to see what the number was.


And then we use this as the input to the next layer. So, that seems weird, why would we delete some data, at random, from our processed image, from our activations after a layer of the convolutions? Well, the reason is that a human is able to look at this corrupted image and still recognize it's a seven, and the idea is that a computer should be able to as well, and if we randomly delete different bits of the activations, each time, then the computer is forced to learn the underlying real representation rather than overfitting. You can think of this as data augmentation, but it's data augmentation not for the inputs, but data augmentation for the activations. So this is called a Dropout Layer. And so Dropout Layers are really helpful for avoiding overfitting. 


And you can decide how much you want to compromise between good generalization – so lack of… so good, you know, avoiding overfitting – versus getting something that works really well on the training data. And so, the more dropout you use, the less good it's going to be on the training data, but the better it ought to generalize.


And so this comes from a paper by Geoffrey Hinton's group, quite a few years ago now, Ruslan's now at Apple, I think.  And then Krizhevsky and Hinton went on to found Google Brain. And so you can see here they've got this picture of a, like, fully connected neural network, two layers, just like the one we built, and here, look, they're kind of randomly deleting some of the activations, and all that's left is these connections. And so, there's a different bunch that's going to be deleted each, each, each batch.


I thought this was an interesting point. So Dropout, which is super important, was actually developed in a master's thesis and it was rejected from the main neural networks conference, then called NIPS, now called NeurIPS. So it ended up being disseminated through… arXiv, which is a preprint server and yes, it's just been pointed out on our chat that Ilya was one of the founders of OpenAI. I don't know what happened to Nitish, I think he went to Google Brain as well, maybe. 


Yeah so, you know, peer review is a very fallible thing, in both directions, and it's great that we have preprint servers so we can read stuff like this, even if reviewers decide it's not worthy, it's been one of the most important papers ever.


Okay, now… 


I think that's given us a good tour now, we've really seen quite a few ways of dealing with input to a neural network, quite a few of the things that can happen in the middle of a neural network. We've already talked about “Rectified Linear Units”, which is… this one here: 0 if “x” is less than 0 or “x” otherwise. These are some of the other activations you can use. Don't use this one, of course, because you end up with a linear model. But they're all just different functions. I should mention, like, it turns out these don't matter very much. Basically pretty much any non-linearity works fine, so we don't spend much time talking about activation functions, even in Part 2 of the course, just a little bit. So yeah, so we understand there are… there's our inputs, they can be one-hot encoded, or embeddings, which is a compute/computational shortcut.  There are sandwich layers of matrix multipliers and activation functions. The matrix multipliers can sometimes be special cases, such as the convolutions or the embeddings. The output can go through some tweaking, such as the Softmax, and then, of course, you've got the loss function such as cross-entropy loss, or mean squared error or mean absolute error. But, you know, it's not… there's nothing too crazy going on in there.


So I feel like we've got a good sense now of, like, what goes inside, you know, a wide range of neural nets, you're not going to see anything too weird from here. And we've also seen a wide range of applications.


So before you come back to do Part 2, you know, what now? And we're going to have a little AMA session here and, in fact, one of the questions was: what now? So this is quite… quite good 


One thing I strongly suggest is, if you've got this far, it's probably worth you investing your time in reading Radek’s book, which is “Meta Learning.”  And so Meta Learning is very heavily based on the kind of teachings of fast.ai over the last few years and is all about how to learn deep learning and learn pretty much anything.


Yeah, because, you know, you've got to this point, you may as well know how to get to the next point as well as possible.


And…


The main thing you'll see that Radek talks about (or one of the main things) is practicing and writing. So if you've kind of zipped through the videos on, you know, 2x and haven't done any exercises, you know, go back and watch the videos again. You know a lot of the best students end up watching them two or three times – probably more, like three times. And actually go through and code as you watch, you know, and experiment. You know, write posts, blog posts, about what you're doing. Spend time on the forum both helping others and seeing other people's answers to questions. Read the success stories on the forum and of people's projects to get inspiration for things you could try. One of the most important things to do is to get together with other people, for example, you can do, you know, a Zoom study group.  In fact on our discord, which you can find through our forum, there's always study groups going on, or you can create your own. You know a study group to go through the book together. Yeah, and of course, you know, build stuff. And sometimes it's tricky to always be able to build stuff for work because maybe there isn't… you're not quite in the right area, or they're not quite ready to try out Deep Learning yet, but that's okay. You know, build some hobby projects, build some stuff just for fun, or build some stuff that you're passionate about. Yes, it's really important to… to not just put the videos away, and go away and do something else because you'll forget everything you've learnt and you won't have practiced.


So one of our community members went on to create an activation function, for example, which is Mish, which is now, as Tanishq has just reminded me on our forums, is now used in many of the state-of-the-art networks around the world, which is pretty cool… this is… and, he's now at Mila, I think, a research… one of the top research labs in the world. I wonder how that's doing? Let's have a look… go to Google Scholar… nice, 486 citations. They're doing great.


All right, let's have a look at how our AMA topic is going and pick out some of the highest ranked AMA’s.


Okay.


So, the first one is from Lucas and… actually maybe I should… actually let's switch our view here.  So, our first AMA is from Lucas. And Lucas asks: “How do you stay motivated? I often find myself overwhelmed in this field, there are so many new things coming up that I feel like I have to put so much energy just to keep my head above the waterline…” 


Yeah, that's a very interesting question, I mean, I think Lucas… the important thing is to realize: you don't have to know everything, you know. In fact nobody knows everything, and that's okay. What people do is they take an interest in some… some area… and they follow that and they try and do their best, the best job they can of keeping up with some little sub area. And if your little sub area is too much to keep up on, pick a sub sub area.
Yeah, there's nothing like… there's no need for it to be demotivating that there's a lot of people doing a lot of interesting work and a lot of different subfields.  That's cool, you know. It used to be kind of dull with, you know, there were only basically five labs in the world working on neural nets.


And yeah, from time to time, you know, take a dip into other areas that maybe you're not following as closely. But when you're… but when you're just starting out you'll find that things are not changing that fast at all really, it can kind of look that way because people are always putting out press releases about their new tweaks, but fundamentally the stuff that is in the course now is not that different to what was in the course five years ago: the foundations haven't changed. And it's not that different, in fact, to the Convolutional Neural Network that Yann LeCun used on MNIST back in 1996. It's, you know, the basic ideas I've described are forever, you know, the way the inputs work and the sandwiches of matrix multipliers and activation functions and the stuff you do to the final layer, you know.  Everything else is tweaks. And the more you learn about those basic ideas, the more you'll recognize those tweaks as simple little tricks that you'll be able to quickly get your head around. 


So then Lucas goes on to ask… or to comment… “Another thing that constantly bothers me is I feel the field is getting more and more skewed towards bigger and more computationally expensive models and huge amounts of data. I keep wondering if in some years from now I would still be able to train reasonable models with a single GPU or if everything is going to require a compute cluster.” 


Yeah, that's a great question, I get that a lot. But interestingly, you know, I've been teaching people machine learning and data science stuff for nearly 30 years and I've had a variation of this question throughout. And the reason is that engineers always want to push the envelope in, like, the… on the biggest computers they can find, you know.  That's just this like fun thing engineers love to do. And, by definition, they're going to get slightly better results than people doing exactly the same thing on smaller computers. So it always looks like: “oh you need big computers to be state-of-the-art.” But that's actually never true, right, because there's always smarter ways to do things, not just bigger ways to do things. And so, you know, when you look at fastai's DAWNBench success when we trained ImageNet faster than anybody had trained it before, on standard GPU’s, you know, me and a bunch of students, that was not meant to happen, you know, Google was working very hard with their TPU introduction to try to show how good they were, Intel was using like 256 PC’s in parallel, or something… but yeah, you know, we used common sense and smarts and showed what can be done. You know, it's also a case of picking the problems you solve. So I would not be probably doing like, going head-to-head up against Codex and trying to create code from english descriptions, you know, because that's a problem that does probably require very large neural nets and very large amounts of data. But if you pick areas in different domains, you know, there's still huge areas where much smaller models are still going to be state-of-the-art.


So hopefully that helped answer your question. All right, let's see what else we got here.


So Daniel has alway been following my journey with teaching my daughter math, yeah he's so: “I homeschool my daughter.” And Daniel asks: “how do you homeschool young children science in general and math in particular? Would you share your experiences by blogging or in lectures someday.” Yeah, I could do that. So I actually spent quite a few months just reading research papers about education recently. So I do probably have a lot I probably need to talk about at some stage. But yeah, broadly speaking, I lean into using computers and tablets, a lot more than most people, because actually there's an awful lot of really great apps that are super compelling – they're adaptive, so they go at the right speed for the student, and they're fun, and I really like my daughter to have fun, you know, I really don't like to force her to do things. And for example there's a really cool app called DragonBox Algebra 5+ which teaches algebra to five-year-olds, by using a really fun computer game involving helping dragon eggs to hatch. And it turns out that yeah, algebra, the basic ideas of algebra, are no more complex than the basic ideas that we do in other kindergarten math and all the parents I know of who have given their kids DragonBox Algebra 5+, their kids have successfully learned algebra. So that would be an example, but yeah, we should talk about this more at some point.


All right, let's see what else we've got here.


So Farah says: “The walk-thrus have been a game changer for me. The knowledge and tips you shared in those sessions are skills required to become an effective machine learning practitioner and utilize fastai more effectively. Have you considered making the walk-thrus a more formal part of the course, doing a separate software engineering course or continuing live-coding sessions between Part 1 & 2?”


So yes, I am going to keep doing live-coding sessions. At the moment we've switched to those, specifically to focusing on APL, and then in a couple of weeks they're going to be going to fast.ai study groups, and then after that they'll gradually turn back into more live-coding sessions. But yeah, the thing I try to do in my live-coding, or study groups, whatever, is yeah, definitely try to show the foundational techniques that just make life easier as a coder or a data scientist. When I say foundational I mean, yeah this, the stuff which you can reuse again and again and again, like learning regular expressions really well, or knowing how to use VIM, or understanding how to use the terminal and command line, you know, all that kind of stuff. Never goes out of style, it never gets old. And yeah, I do plan to, at some point, hopefully, actually do a course really all about that stuff specifically, but yeah, for now the, for now the best approach is follow along with the live-coding and stuff. 


Okay wgpubs, which is Wade, asks: “How do you turn a model into a business? Specifically, how does a coder with little or no startup experience turn an ML based gradio prototype into a legitimate business venture?”. 


Okay, I plan to do a course about this, at some point, as well. So, you know, obviously there isn't a two-minute version to this, but the key thing with creating a legitimate business venture is to solve a legitimate problem, you know, a problem that people need solved/solving. And which they will pay you to solve. 


And so, it's important not to start with your fun gradio prototype as the basis your business, but instead, start with: here's a problem I want to solve. And generally speaking you should try to pick a problem that you understand better than most people. So it's either a problem that you face day to day in your work, or in some hobby or passion that you have, or that, you know, your club has or your local school has, or your… your spouse deals with in their workplace, you know. It's something where you understand that there's a… something that doesn't work as well as it ought to. Particularly something where you think to yourself: “you know, if they just used Deep Learning here, or some algorithm here, or some better compute here, that problem would go away.”  And that's, that's the start of a business. And so then, my friend Eric Ries wrote a book called “The Lean Startup” where he describes what you do next, which is basically, you fake it. You create, so he calls it,  the “minimum viable product”. You create something that solves that problem, it takes you as little time as possible to create. It could be very manual, it can be loss making, it's fine. You know, even the bit in the middle where you're like: “oh there's going to be a neural net here…” it's fine to, like, launch without the neural net and do everything by hand. 


You're just trying to find out: “are people going to pay for this?” and is this actually useful? And then once you have, you know, hopefully confirmed that the need is real, and that people will pay for it, and you can solve the need, you can gradually make it less and less of a fake, you know, and to you know more and more getting the product to where you want it to be.


Okay, I don't know how to pronounce the name m-i-w-o-j-c, m-i-w-o-j-c says: “Jeremy, can you share some of your productivity hacks? From the content you produce that may seem you work 24 hours a day?” 


Okay, I certainly don't do that. I think one of my main productivity hacks actually is not to work too hard. Or at least… no, not to work too hard…  not to work too much. I spend, probably, less hours a day working than most people, I would guess, but I think I do a couple of things differently when I'm working. One is I've spent half, at least half,  of every working day, since I was about 18, learning or practicing something new.


Could be a new language, it could be a new algorithm, it could be something I read about. And, nearly all of that time, therefore, I've been doing that thing more slowly than I would if I just used something I already knew – which often drives my co-workers crazy because they're like, you know: “why aren't you focusing on getting that thing done”. But in the other 50% of the time I'm constantly, you know, building up this kind of exponentially improving base of expertise, in a wide range of areas. And so now I do find, you know, I can do things, often, orders of magnitude faster than people around me or certainly many multiples faster than people around me because I, you know, know a whole bunch of tools and skills and ideas which (yeah/no) other people don't necessarily know. So like I think that's one thing that's been helpful. And then another is, yeah, like trying to really not overdo things, like get good sleep, and eat well, and exercise well.


And also I think it's a case of like, tenacity, you know, I've noticed a lot of people give up much earlier than I do. So yeah, if you, if you just keep going until something's actually finished then that's going to put you in a small minority, to be honest, most people don't do that. When I say finish, like finish something really nicely. And I try to make it like… so I particularly like coding and so I try to do a lot of coding related stuff. So I create things like nbdev, and nbdev makes it much much easier for me to finish something nicely, you know. So, in my kind of chosen area I've spent quite a bit of time trying to make sure it's really easy for me to like, get out a blog post, get out a Python library, get out a notebook analysis, whatever. So yeah, trying to make these things I want to do easier and so then I'll do them more.


So, well, thank you everybody. That's been a lot of fun. Really appreciate you taking the time to go through this course with me. Yeah, if you enjoyed it, it would really help if you would give a like on youtube, because it really helps other people find the course… goes into the youtube recommendation system. And please do come and help other beginners on forums.fast.ai. It's a great way to learn yourself… is to try to teach other people. And yeah, I hope you'll join us in Part 2. Thanks very much… thanks everybody, very much. I really enjoyed this process and I hope to…, I get to meet more of you in person in the future. Bye.